Use from Python
===============


Connect to the server
---------------------

Before you can do anything useful, you need to create a `TomcatManager` object
and connect to a server.

.. automethod:: tomcatmanager.tomcat_manager.TomcatManager.connect
   :noindex:


Responses from the server
-------------------------

All the methods of :class:`.TomcatManager` which interact with the server
return a response in the form of a :class:`.TomcatManagerResponse` object.
Use this object to check whether the command completed successfully, and to
get any results generated by the command.

.. autoclass:: tomcatmanager.models.TomcatManagerResponse
   :members:
   :noindex:


Managing Applications
---------------------

This library provides a robust API to manage applications in a tomcat server.
The following methods are available:

- :meth:`.TomcatManager.list` - return a list of all installed applications
- :meth:`.TomcatManager.deploy_localwar` - deploy a local war file to the server
- :meth:`.TomcatManager.deploy_serverwar` - deploy a war file already on the tomcat server
- :meth:`.TomcatManager.deploy_servercontext` - deploy a tomcat application defined by a context file on the server
- :meth:`.TomcatManager.undeploy` - remove a tomcat application installed on the server
- :meth:`.TomcatManager.start` - start a deployed tomcat application that isn't running
- :meth:`.TomcatManager.stop` - stop a running tomcat application and leave it installed
- :meth:`.TomcatManager.reload` - stop and start a tomcat application
- :meth:`.TomcatManager.sessions` - show active sessions for a tomcat application
- :meth:`.TomcatManager.expire` - expire idle sessions


Parallel Deployment
-------------------

Tomcat supports a `parallel deployment feature
<https://tomcat.apache.org/tomcat-8.5-doc/config/context.html#Parallel_deplo
yment>`_ which allows multiple versions of the same WAR to be deployed
simultaneously at the same URL. To utilize this feature, you need to deploy an
application with a version string. The combination of path and version string
uniquely identify the application::

   >>> tomcat = getfixture('tomcat')
   >>> safe_path = getfixture('safe_path')
   >>> localwar_file = getfixture('localwar_file')
   >>> with open(localwar_file, 'rb') as localwar_fileobj:
   ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version='42')
   ...     r.ok
   True
   >>> with open(localwar_file, 'rb') as localwar_fileobj:
   ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version='43')
   ...     r.ok
   True

We now have two instances of the same application, deployed at the same
location, but with different version strings. To do anything to either of those
applications, you must supply both the path and the version string::

   >>> r = tomcat.stop(path=safe_path, version='42')
   >>> r.ok
   True
   >>> r = tomcat.undeploy(path=safe_path, version='42')
   >>> r.ok
   True
   >>> r = tomcat.undeploy(path=safe_path, version='43')
   >>> r.ok
   True

The following methods include an optional version parameter to support parallel
deployments:

- :meth:`~.TomcatManager.deploy_localwar`
- :meth:`~.TomcatManager.deploy_serverwar`
- :meth:`~.TomcatManager.deploy_servercontext`
- :meth:`~.TomcatManager.undeploy`
- :meth:`~.TomcatManager.start`
- :meth:`~.TomcatManager.stop`
- :meth:`~.TomcatManager.reload`
- :meth:`~.TomcatManager.sessions`
- :meth:`~.TomcatManager.expire`


Information about Tomcat
------------------------

There are a number of methods which just return information about the Tomcat
server. With the exception of :meth:`TomcatManager.find_leakers` (which
triggers garbage collection), these methods don't effect any change on the
server.

- :meth:`TomcatManager.find_leakers` - find applications that are leaking memory
- :meth:`TomcatManager.resources` - get global JNDI resources
- :meth:`TomcatManager.server_info` - get information about the tomcat server
- :meth:`TomcatManager.status_xml` - get server status information in xml format
- :meth:`TomcatManager.thread_dump` - get a jvm thread dump
- :meth:`TomcatManager.vm_info` - get diagnostic information about the jvm


SSL/TLS
-------

Tomcat servers can be configured to serve their applications over SSL/TLS.
This library includes a few related methods:

- :meth:`TomcatManager.ssl_connector_ciphers`
- :meth:`TomcatManager.ssl_connector_certs`
- :meth:`TomcatManager.ssl_connector_trusted_certs`
- :meth:`TomcatManager.ssl_reload`

The :meth:`TomcatManager.ssl_reload` is the only one of these methods that
causes the server to take any action, the rest are informational only.


Differences in Server Versions
------------------------------

Not every version of Tomcat supports all of the methods in this library. If
you call a method that is not implemented by the particular server you are
connected to, :exc:`~.models.TomcatNotImplementedError` will be raised.

If you prefer to check whether a method is supported before calling it, you
can do so using :meth:`.TomcatManager.implements`:

   >>> tomcat = getfixture('tomcat')
   >>> if tomcat.implements(tomcat.list):
   ...     print("list is implemented")
   ... else:
   ...     print("list is not implemented")
   list is implemented

If you call :meth:`.TomcatManager.implements` and are not connected to a
server, :exc:`~.models.TomcatNotConnected` will be raised.

There is a way to check whether a method is supported without connecting
to a server. You must specify the version of the Tomcat server and the
method you want to check is implemented. Use one of the values in the enumeration
:class:`~.models.TomcatMajorMinor` to specify the version of Tomcat you
want to check::

   >>> import tomcatmanager as tm
   >>> tomcat = tm.TomcatManager()
   >>> tver = tm.TomcatMajorMinor.V7_0
   >>> print(tomcat.implemented_by(tomcat.ssl_reload, tver))
   False
